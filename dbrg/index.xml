<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Database Reading Group | DIPr Lab at PSU</title>
    <link>https://diprlab.github.io/dbrg/</link>
      <atom:link href="https://diprlab.github.io/dbrg/index.xml" rel="self" type="application/rss+xml" />
    <description>Database Reading Group</description>
    <generator>Hugo Blox Builder (https://hugoblox.com)</generator><language>en-us</language><lastBuildDate>Fri, 30 May 2025 00:00:00 +0000</lastBuildDate>
    <image>
      <url>https://diprlab.github.io/media/logo_hu_f67add51057eb433.png</url>
      <title>Database Reading Group</title>
      <link>https://diprlab.github.io/dbrg/</link>
    </image>
    
    <item>
      <title>Spring 2025 Week 9</title>
      <link>https://diprlab.github.io/dbrg/events/2025_spring_09/</link>
      <pubDate>Fri, 30 May 2025 00:00:00 +0000</pubDate>
      <guid>https://diprlab.github.io/dbrg/events/2025_spring_09/</guid>
      <description>&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;
      Title
    &lt;/td&gt;
    &lt;td&gt;
      In-Database Time Series Clustering
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;
      Authors
    &lt;/td&gt;
    &lt;td&gt;
      Yunxiang Su, Kenny Ye Liang, Shaoxu Song
    &lt;/td&gt;
  &lt;/tr&gt;
    &lt;tr&gt;
   &lt;td&gt;
      Abstract
    &lt;/td&gt;
    &lt;td&gt;
      Time series data are often clustered repeatedly across various time ranges to mine frequent subsequence patterns from different periods, which could further support downstream applications. Existing state-of-the-art (SOTA) time series clustering method, such as K-Shape, can proficiently cluster time series data referring to their shapes. However, in-database time series clustering problem has been neglected, especially in IoT scenarios with large-volume data and high efficiency demands. Most time series databases employ LSM-Tree based storage to support intensive writings, yet causing underlying data points out-of-order in timestamps. Therefore, to apply existing out-of-database methods, all data points must be fully loaded into memory and chronologically sorted. Additionally, out-of-database methods must cluster from scratch each time, making them inefficient when handling queries across different time ranges. In this work, we propose an in-database adaptation of SOTA time series clustering method K-Shape. Moreover, to solve the problem that K-Shape cannot efficiently handle long time series, we propose Medoid-Shape, as well as its in-database adaptation for further acceleration. Extensive experiments are conducted to demonstrate the higher efficiency of our proposals, with comparable effectiveness. Remarkably, all proposals have already been implemented in an open-source commodity time series database, Apache IoTDB.
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Spring 2025 Week 8</title>
      <link>https://diprlab.github.io/dbrg/events/2025_spring_08/</link>
      <pubDate>Fri, 23 May 2025 00:00:00 +0000</pubDate>
      <guid>https://diprlab.github.io/dbrg/events/2025_spring_08/</guid>
      <description>&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;
      Title
    &lt;/td&gt;
    &lt;td&gt;
      Highly Efficient and Scalable Access Control Mechanism for IoT Devices in Pervasive Environments
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;
      Authors
    &lt;/td&gt;
    &lt;td&gt;
      Alian Yu, Jian Kang, Wei Jiang and Dan Lin
    &lt;/td&gt;
  &lt;/tr&gt;
    &lt;tr&gt;
   &lt;td&gt;
      Abstract
    &lt;/td&gt;
    &lt;td&gt;
      With the continuous advancement of sensing, networking, controlling, and computing technologies, there is a growing number of IoT (Internet of Things) devices emerging that are expected to integrate into public infrastructure in the near future. However, the deployment of these smart devices in public venues presents new challenges for existing access control mechanisms, particularly in terms of efficiency. To address these challenges, we have developed a highly efficient and scalable access control mechanism that enables automatic and fine-grained access control management while incurring low overhead in large-scale settings. Our mechanism includes a dual-hierarchy access control structure and associated information retrieval algorithms, which we have used to develop a large-scale IoT device access control system called FACT+. FACT+ overcomes the efficiency issues of granting and inquiring access control status over millions of devices in pervasive environments. Additionally, our system offers a pay-and-consume scheme and plug-and-play device management for convenient adoption by service providers. We have conducted extensive experiments to demonstrate the practicality, effectiveness, and efficiency of our access control mechanism.
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Spring 2025 Week 6</title>
      <link>https://diprlab.github.io/dbrg/events/2025_spring_06/</link>
      <pubDate>Fri, 09 May 2025 00:00:00 +0000</pubDate>
      <guid>https://diprlab.github.io/dbrg/events/2025_spring_06/</guid>
      <description>&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;
      Title
    &lt;/td&gt;
    &lt;td&gt;
      Grouping, Subsumption, and Disjunctive Join Optimizations in Oracle
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;
      Authors
    &lt;/td&gt;
    &lt;td&gt;
      Rafi Ahmed, Krishna Kantikiran Pasupuleti, Sriram Tirupattur, Lei Sheng, Hong Su, Mohamed Ziauddin
    &lt;/td&gt;
  &lt;/tr&gt;
    &lt;tr&gt;
   &lt;td&gt;
      Abstract
    &lt;/td&gt;
    &lt;td&gt;
      Query optimization must evolve with new workloads. As analytic and data warehouse workloads become more ubiquitous, optimization techniques that reduce the amount of data processed during query execution, enable shared computation and avoid expensive data access and joins must be rigorously explored. In this paper, we present aggregate-decomposition techniques as enhancements to an existing query transformation that performs grouping before joins. Consequently, the transformation generates more query rewrite candidates and can also be applied to a larger set of queries. Further, we introduce two new query transformations, i) subsumption of views and subqueries that explores opportunities for sharing computation and ii) union-all duplicator transformation for queries with disjunctive join predicates that removes the need for multiple data access and joins. These techniques are applicable to commonly noticed query patterns in customer workloads and provide significant performance benefit as indicated in our performance study. They have been implemented in Oracle RDBMS.
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Spring 2025 Week 4</title>
      <link>https://diprlab.github.io/dbrg/events/2025_spring_04/</link>
      <pubDate>Fri, 25 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://diprlab.github.io/dbrg/events/2025_spring_04/</guid>
      <description>&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;
      Title
    &lt;/td&gt;
    &lt;td&gt;
      How good are query optimizers, really?
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;
      Authors
    &lt;/td&gt;
    &lt;td&gt;
      Viktor Leis, Andrey Gubichev, Atanas Mirchev, Peter Boncz, Alfons Kemper, Thomas Neumann
    &lt;/td&gt;
  &lt;/tr&gt;
    &lt;tr&gt;
   &lt;td&gt;
      Abstract
    &lt;/td&gt;
    &lt;td&gt;
      Finding a good join order is crucial for query performance. In this paper, we introduce the Join Order Benchmark (JOB) and experimentally revisit the main components in the classic query optimizer architecture using a complex, real-world data set and realistic multi-join queries. We investigate the quality of industrial-strength cardinality estimators and find that all estimators routinely produce large errors. We further show that while estimates are essential for finding a good join order, query performance is unsatisfactory if the query engine relies too heavily on these estimates. Using another set of experiments that measure the impact of the cost model, we find that it has much less influence on query performance than the cardinality estimates. Finally, we investigate plan enumeration techniques comparing exhaustive dynamic programming with heuristic algorithms and find that exhaustive enumeration improves performance despite the sub-optimal cardinality estimates.
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Spring 2025 Week 3</title>
      <link>https://diprlab.github.io/dbrg/events/2025_spring_03/</link>
      <pubDate>Fri, 18 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://diprlab.github.io/dbrg/events/2025_spring_03/</guid>
      <description>&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;
      Title
    &lt;/td&gt;
    &lt;td&gt;
      PDX: A Data Layout for Vector Similarity Search
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;
      Authors
    &lt;/td&gt;
    &lt;td&gt;
      Leonardo Kuffo, Elena Krippner, and Peter Boncz from CWI Amsterdam, The Netherlands
    &lt;/td&gt;
  &lt;/tr&gt;
    &lt;tr&gt;
   &lt;td&gt;
      Abstract
    &lt;/td&gt;
    &lt;td&gt;
      We propose Partition Dimensions Across (PDX), a data layout for vectors (e.g., embeddings) that, similar to PAX, stores multiple vectors in one block, using a vertical layout for the dimensions (Figure 1). PDX accelerates exact and approximate similarity search thanks to its dimension-by-dimension search strategy that operates on multiple-vectors-at-a-time in tight loops. It beats SIMD-optimized distance kernels on standard horizontal vector storage (avg 40% faster), only relying on scalar code that gets auto-vectorized. We combined the PDX layout with recent dimension-pruning algorithms ADSampling and BSA that accelerate approximate vector search. We found that these algorithms on the horizontal vector layout can lose to SIMD-optimized linear scans, even if they are SIMD-optimized. However, when used on PDX, their benefit is restored to 2-7x. We find that search on PDX is especially fast if a limited number of dimensions has to be scanned fully, which is what the dimension-pruning approaches do. We finally introduce PDX-BOND, an even more flexible dimension-pruning strategy, with good performance on exact search and reasonable performance on approximate search. Unlike previous pruning algorithms, it can work on vector data &#34;as-is&#34; without preprocessing; making it attractive for vector databases with frequent updates.
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</description>
    </item>
    
    <item>
      <title>Spring 2025 Week 1</title>
      <link>https://diprlab.github.io/dbrg/events/2025_spring_01/</link>
      <pubDate>Fri, 04 Apr 2025 00:00:00 +0000</pubDate>
      <guid>https://diprlab.github.io/dbrg/events/2025_spring_01/</guid>
      <description>&lt;table&gt;
  &lt;tr&gt;
    &lt;td&gt;
      Title
    &lt;/td&gt;
    &lt;td&gt;
      Navigating Labels and Vectors: A Unified Approach to Filtered Approximate Nearest Neighbor Search
    &lt;/td&gt;
  &lt;/tr&gt;
  &lt;tr&gt;
   &lt;td&gt;
      Authors
    &lt;/td&gt;
    &lt;td&gt;
      Yuzheng Cai, Jiayang Shi, Yizhuo Chen, Weigue Zheng
    &lt;/td&gt;
  &lt;/tr&gt;
    &lt;tr&gt;
   &lt;td&gt;
      Abstract
    &lt;/td&gt;
    &lt;td&gt;
      Given a query vector, approximate nearest neighbor search (ANNS) aims to retrieve similar vectors from a set of high-dimensional base vectors. However, many real-world applications jointly query both vector data and structured data, imposing label constraints such as attributes and keywords on the search, known as filtered ANNS. Effectively incorporating filtering conditions with vector similarity presents significant challenges, including index for dynamically filtered search space, agnostic query labels, computational overhead for label-irrelevant vectors, and potential inadequacy in returning results. To tackle these challenges, we introduce a novel approach called the Label Navigating Graph, which encodes the containment relationships of label sets for all vectors. Built upon graph-based ANNS methods, we develop a general framework termed Unified Navigating Graph (UNG) to bridge the gap between label set containment and vector proximity relations. UNG offers several advantages, including versatility in supporting any query label size and specificity, fidelity in exclusively searching filtered vectors, completeness in providing sufficient answers, and adaptability in integration with most graph-based ANNS algorithms. Extensive experiments on real datasets demonstrate that the proposed framework outperforms all baselines, achieving 10x speedups at the same accuracy.
    &lt;/td&gt;
  &lt;/tr&gt;
&lt;/table&gt;
</description>
    </item>
    
  </channel>
</rss>
